{
  "api/Glasgow.CryptographyUtil.html": {
    "href": "api/Glasgow.CryptographyUtil.html",
    "title": "Class CryptographyUtil | Glasgow",
    "summary": "Class CryptographyUtil Namespace Glasgow Assembly Glasgow.dll Provides utility methods for cryptographic operations used throughout GlasgowDB, including secure key derivation from passwords or passphrases. public class CryptographyUtil Inheritance object CryptographyUtil Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class is intended to centralize cryptographic routines such as PBKDF2-based key derivation, ensuring consistent parameters (iteration count, hash algorithm) across the application. All methods are static, as they do not maintain internal state. Security Considerations: Always use a sufficiently random, unique salt when deriving keys. Reusing salts across different data or users can weaken security by making pre-computation attacks easier. The iteration count (100,000) strikes a balance between performance and security as of 2025. Adjust upward if hardware allows, to increase resistance against brute-force attacks. The derived key length is fixed at 32 bytes (256 bits), suitable for AES-256. If a different cipher or key size is required, consider exposing a parameter to change output length. PBKDF2 with HMAC-SHA256 is widely supported and considered secure for password-based key derivation. However, if future requirements demand a memory-hard function (e.g., Argon2), this utility should be updated. Methods DeriveKey(string, byte[]) Derives a 256-bit (32-byte) symmetric encryption key from the provided passphrase and salt, using the PBKDF2 (Password-Based Key Derivation Function 2) algorithm (RFC 2898) with HMAC-SHA256 and 100,000 iterations. public static byte[] DeriveKey(string PassKey, byte[] Salt) Parameters PassKey string The user-supplied passphrase or password from which to derive the key. This should be a strong, high-entropy string (e.g., a randomly generated password or user-provided phrase). Using weak or guessable passphrases can severely reduce the security of the derived key. Salt byte[] A cryptographic salt value, represented as a byte array. The salt must be at least 16 bytes long and should be generated using a secure random number generator (e.g., RandomNumberGenerator). Each distinct usage (e.g., per encrypted database file or per user) should employ a unique, unpredictable salt. Returns byte[] A byte array of length 32, containing the derived 256-bit key. This key is suitable for use with AES-256 or other symmetric encryption algorithms requiring a 32-byte key. Remarks Algorithm Details: Instantiates an Rfc2898DeriveBytes (PBKDF2) object with: The provided PassKey as the password. The provided Salt as the salt. An iteration count of 100,000, meaning the HMAC-SHA256 function is applied repeatedly 100,000 times to slow down brute-force attacks. The underlying hash algorithm SHA256. Calls GetBytes(32) to produce a 32-byte key derived from the passphrase and salt. Disposes the Rfc2898DeriveBytes instance immediately after key extraction, ensuring no sensitive data lingers in memory longer than necessary. Performance and Security Tradeoff: The iteration count (100,000) is chosen to be sufficiently high to deter brute-force attacks while still allowing reasonably fast key derivation on modern hardware. If low-latency is critical and hardware is less capable, consider lowering the iteration count (at the cost of reduced security). Conversely, if your threat model demands stronger resistance, increase the iteration count or switch to a memory-hard KDF. Error Handling: This method throws an ArgumentNullException if either PassKey or Salt is null. If Salt is empty or poorly random, the derived key may be less secure. Exceptions ArgumentNullException Thrown if PassKey or Salt is null."
  },
  "api/Glasgow.DataTypes.html": {
    "href": "api/Glasgow.DataTypes.html",
    "title": "Enum DataTypes | Glasgow",
    "summary": "Enum DataTypes Namespace Glasgow Assembly Glasgow.dll Enumerates all supported data types used by the GlasgowDB system for serializing and storing values in its internal tabular structure. Each enumeration value corresponds to a specific .NET type and dictates how the value is serialized, deserialized, stored, and interpreted within the database engine. These types ensure compatibility with common .NET primitives and are essential for consistent binary serialization handled by Glasgow.SerializerUtil. The Glasgow.SerializerUtil uses this enum as metadata to identify the type of value being serialized or deserialized, enabling type-safe reconstruction of data across sessions, storage layers, or transport boundaries. public enum DataTypes : byte Fields Blob = 7 Represents a binary large object (BLOB) as a byte array (System.Byte[]). This type is suitable for storing raw binary content such as images, documents, encoded data, or custom-serialized objects. Size limitations depend on the implementation and system resources. Use Case: Profile pictures, encrypted blobs, audio samples, custom payloads. Boolean = 5 Represents a boolean value (System.Boolean), either true or false. Useful for toggles, feature flags, conditionals, and binary state indicators. Use Case: IsActive flag, IsAdmin role, enabled/disabled states. DateTime = 6 Represents a date and time value (System.DateTime). Serialized using a standard format (e.g., ticks or ISO 8601), this type enables temporal data storage such as timestamps, schedules, and audit trails. Use Case: CreatedAt, updatedAt, expiration dates, appointment slots. Decimal = 9 Represents a decimal number with high precision (System.Decimal). Ideal for storing financial and monetary values where precision and scale are critical, as this type avoids rounding errors common with floating-point types. Use Case: Currency, tax calculations, interest rates, accounting figures. Double = 3 Represents a double-precision floating-point number (System.Double). Useful for storing numeric values requiring high range and precision (15-16 digits of accuracy), such as measurements, scientific data, or results from floating-point calculations. Use Case: GPS coordinates, sensor data, weights, temperature. Float = 8 Represents a single-precision floating-point number (System.Single). Offers less precision (7 digits) and range than a Double, but uses less memory and is often sufficient for performance-sensitive applications or graphical data. Use Case: Game data, vector coordinates, approximate calculations. Integer = 1 Represents a 32-bit signed integer (System.Int32). Commonly used for numeric values such as counters, identifiers, or index values that fit within the range of -2,147,483,648 to 2,147,483,647. Use Case: Row IDs, user age, quantity, flags, or enum storage. Long = 2 Represents a 64-bit signed integer (System.Int64). Suitable for large numeric values that exceed the 32-bit integer range, such as file sizes, timestamps (Unix epoch), or large counters. Use Case: Epoch time, database auto-increment keys, large data IDs. Null = 0 Represents a null or undefined value. This is equivalent to null in .NET and is used to store missing or unset entries in a table row. During serialization, this acts as a placeholder without a concrete value. On deserialization, it is interpreted as a null reference. Use Case: Optional fields, empty table cells, or schema placeholders. String = 4 Represents a Unicode text string (System.String). This type can hold arbitrarily long text values encoded in UTF-8 or UTF-16, depending on the internal serialization strategy. It supports internationalization and complex text content. Use Case: Names, descriptions, serialized JSON, user input, messages."
  },
  "api/Glasgow.DatabaseIO.html": {
    "href": "api/Glasgow.DatabaseIO.html",
    "title": "Class DatabaseIO | Glasgow",
    "summary": "Class DatabaseIO Namespace Glasgow Assembly Glasgow.dll Handles secure serialization and deserialization of a GlasgowDB instance to and from disk. This class provides AES-256-CBC encryption for secure database persistence, using a passphrase-derived key via PBKDF2 and a randomly generated Initialization Vector (IV) embedded at the start of the file. All data (including table structure and row content) is stored in a binary format after encryption. Security Considerations: Encryption uses AES-256-CBC for strong symmetric encryption. Keys are derived from passphrases using PBKDF2 to resist brute force attacks. The IV is stored unencrypted at the beginning of the file and is used for key derivation and decryption. Typical Usage: - Use SaveToFile(GlasgowDB, string, string) to persist a GlasgowDB securely. - Use LoadFromFile(string, string) to recover it using the same passphrase. public class DatabaseIO Inheritance object DatabaseIO Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods LoadFromFile(string, string) Loads and decrypts a GlasgowDB instance from the specified encrypted file. If the file does not exist, an empty instance is returned (i.e., a new GlasgowDB with no tables). Decryption uses the AES-256-CBC algorithm with a passphrase-derived key using PBKDF2. The IV required for decryption is read from the beginning of the file. public static GlasgowDB LoadFromFile(string FileName, string PassKey) Parameters FileName string Path to the encrypted file containing the serialized database. PassKey string Passphrase to derive the decryption key. Must match the passphrase used to save the file. Returns GlasgowDB A populated GlasgowDB instance if decryption and deserialization succeed, or an empty instance if the file is missing. Exceptions EndOfStreamException Thrown if the file is too short to contain a valid IV or unexpectedly ends during reading. InvalidOperationException Thrown when the passphrase is incorrect or the file is corrupted, leading to decryption failure or unexpected binary format during deserialization. SaveToFile(GlasgowDB, string, string) Saves the given GlasgowDB instance to an encrypted file at the specified path, using AES-256 in CBC mode. The file will begin with a randomly generated IV. A random Initialization Vector (IV) is generated for each write and stored at the beginning of the file. The encryption key is derived from the provided passphrase and this IV using PBKDF2. public static void SaveToFile(GlasgowDB Database, string FileName, string PassKey) Parameters Database GlasgowDB The GlasgowDB to serialize and encrypt. FileName string The destination file path. If the file already exists, it will be overwritten. PassKey string The passphrase used to derive the AES encryption key. Must be provided again to decrypt via LoadFromFile(string, string)."
  },
  "api/Glasgow.DeleteCommand.html": {
    "href": "api/Glasgow.DeleteCommand.html",
    "title": "Class DeleteCommand | Glasgow",
    "summary": "Class DeleteCommand Namespace Glasgow Assembly Glasgow.dll Constructs and runs a DELETE operation against a specified table in a GlasgowDB instance. This class leverages the filtering functionality inherited from QueryBase to enable WHERE clauses that refine which rows to remove. Each Where(Operator, string, object) call adds an additional predicate: all predicates are combined with logical AND semantics. Example usage: int deletedCount = db.Delete(\"Users\") .Where(Operator.EQUALS, \"IsActive\", false) .Where(Operator.LESS_THAN, \"LastLogin\", someDate) .Execute(); This example deletes all rows in the \"Users\" table that are inactive and have a last login earlier than someDate. If the specified table does not exist in the database, Execute() returns zero without throwing. public class DeleteCommand : QueryBase Inheritance object QueryBase DeleteCommand Inherited Members QueryBase._filters QueryBase.IsNumericType(Type) QueryBase.WildcardMatch(string, string) QueryBase.Where<T>(Operator, string, object) QueryBase.ApplyFilters(IEnumerable<Dictionary<string, object>>) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DeleteCommand(GlasgowDB, string) Constructs and runs a DELETE operation against a specified table in a GlasgowDB instance. This class leverages the filtering functionality inherited from QueryBase to enable WHERE clauses that refine which rows to remove. Each Where(Operator, string, object) call adds an additional predicate: all predicates are combined with logical AND semantics. Example usage: int deletedCount = db.Delete(\"Users\") .Where(Operator.EQUALS, \"IsActive\", false) .Where(Operator.LESS_THAN, \"LastLogin\", someDate) .Execute(); This example deletes all rows in the \"Users\" table that are inactive and have a last login earlier than someDate. If the specified table does not exist in the database, Execute() returns zero without throwing. public DeleteCommand(GlasgowDB Instance, string Table) Parameters Instance GlasgowDB The GlasgowDB instance against which this delete operation will be performed. All modifications occur directly in this instance's in-memory table store. Table string The name of the table from which rows should be deleted. Must be a non-null, non-empty string; if the table does not exist, no action is taken. Methods Execute() Executes the DELETE operation: all rows in the specified table matching every filter predicate added via Where(Operator, string, object) calls will be removed. The deletion occurs in two phases for safety: Identify and collect all matching rows without modifying the original row list. Iterate through the collected rows, removing each from the table and incrementing a counter. public int Execute() Returns int The total number of rows successfully deleted. If the table does not exist, returns 0. Remarks Filtering logic: For each row in the target table, each predicate in _filters (inherited from QueryBase) is invoked. Only rows for which every predicate returns true are slated for deletion. Deletion logic: By first collecting matching rows into a separate list, this method avoids modifying the underlying collection while enumerating it. Removal is then performed in a second pass, ensuring thread-safety concerns are minimized (though GlasgowDB itself is not inherently thread-safe). After deletion, the table’s Rows list is permanently altered. There is no rollback mechanism: once Execute() returns, deleted rows cannot be recovered unless an external copy or snapshot was maintained. If multiple DeleteCommand objects operate concurrently on the same table from different threads without synchronization, the result may be non-deterministic due to race conditions on List.Remove. Exceptions InvalidOperationException This method does not throw on missing table—but if filters or table data are corrupted, unexpected exceptions may bubble up (e.g., NullReferenceException if internal state is invalid). Where(Operator, string, object) Adds a filtering condition (a WHERE clause) to the delete operation. Each call refines the deletion scope: only rows satisfying Operation on ColumnName against Value will be considered. Multiple calls combine predicates using logical AND. public DeleteCommand Where(Operator Operation, string ColumnName, object Value) Parameters Operation Operator The comparison operator to use when evaluating each row’s column value against Value. Supported operators include: EQUALS: Checks for equality (numeric, string, boolean, DateTime, or byte[]). NOT_EQUALS: Checks for inequality. LESS_THAN, GREATER_THAN, LESS_THAN_OR_EQUAL, GREATER_THAN_OR_EQUAL: Numeric or DateTime comparisons. CONTAINS, STARTS_WITH, ENDS_WITH: String comparisons (case-insensitive; CONTAINS checks substring, etc.). ColumnName string The name of the column in each row to evaluate. If a row does not contain this column, that row is excluded. Column name comparison is case-sensitive and must match one of the table’s schema columns. Value object The value to compare against. Its runtime type must match the column’s data type (e.g., int, string, DateTime, bool, or byte[]). For string equality/inequality, wildcard patterns using '*' are supported. Returns DeleteCommand The same DeleteCommand instance, allowing subsequent Where(Operator, string, object) calls to further refine the filter. Remarks Internally, this method calls the generic Where<T>(Operator, string, object) implementation, which appends a predicate delegate into the inherited _filters list. When Execute() is invoked, only rows satisfying all accumulated predicates are deleted."
  },
  "api/Glasgow.GlasgowDB.html": {
    "href": "api/Glasgow.GlasgowDB.html",
    "title": "Class GlasgowDB | Glasgow",
    "summary": "Class GlasgowDB Namespace Glasgow Assembly Glasgow.dll Represents an in-memory database that holds named tables and provides basic relational operations (CREATE, DROP, INSERT, SELECT, DELETE, UPDATE). All data is stored in memory as Table objects, each identified by a unique string name. This class is not thread-safe: concurrent modifications (e.g., two threads inserting into the same table) can lead to inconsistent state. If thread safety is required, external synchronization must be applied. Example usage: // Create a new database var db = new GlasgowDB(); // Create a table \"Users\" with columns \"Id\", \"Name\", \"Email\" db.CreateTable(\"Users\", \"Id\", \"Name\", \"Email\"); // Insert a row into \"Users\" db.InsertInto( \"Users\", new[] { \"Id\", \"Name\", \"Email\" }, new object[] { 1, \"Alice\", \"alice@example.com\" } ); // Query the \"Users\" table var results = db.Select(\"Users\", \"Id\", \"Name\") .Where(Operator.EQUALS, \"Name\", \"Alice\") .ToList(); foreach (var row in results) { Console.WriteLine($\"Id: {row[\"Id\"]}, Name: {row[\"Name\"]}\"); } // Delete inactive users int deleted = db.Delete(\"Users\") .Where(Operator.EQUALS, \"IsActive\", false) .Execute(); // Drop the \"Users\" table entirely bool dropped = db.DropTable(\"Users\"); public class GlasgowDB Inheritance object GlasgowDB Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors GlasgowDB() Initializes a new, empty GlasgowDB instance with no tables. public GlasgowDB() Remarks Internally, this constructor allocates a new Dictionary<TKey, TValue> to hold tables by name. Subsequent operations (CreateTable, InsertInto, etc.) will populate this dictionary. Properties Database A dictionary of tables in this database, keyed by table name. Each key corresponds to a Table instance that contains its own schema and rows. public Dictionary<string, Table> Database { get; set; } Property Value Dictionary<string, Table> Remarks Table names are case-sensitive; two names that differ only by case are considered distinct. Modifications (Insert/Delete/Update) operate directly on the Rows list. To check if a table exists, use Database.ContainsKey(tableName). Methods CreateTable(string, params string[]) Creates a new table in the database with the specified name and initial columns. public bool CreateTable(string TableName, params string[] ColumnNames) Parameters TableName string The name for the new table. Must be a non-null, non-empty string. If a table with this name already exists, creation fails and no changes are made. ColumnNames string[] A variable-length array of column names to define the table’s schema. Each column name must be unique within this table and non-null/non-empty. If ColumnNames is empty, the new table will initially have zero columns; columns can be added later upon insertion. Returns bool true if the table was created successfully; false if a table with the same name already exists. Remarks This method does not validate that ColumnNames are unique at the call site; however, duplicate names in the same array will result in multiple entries in Table.ColumnNames. It is the caller’s responsibility to avoid passing duplicate column names. After creation, the new table is accessible via Database[TableName]. Subsequent InsertInto(string, string[], object[]) calls on this table will add rows to it. The return value false indicates that no exception was thrown, but the operation was a no-op because the table already existed. Use DropTable(string) followed by CreateTable(string, params string[]) if you need to re-create a table with the same name. Delete(string) Initiates a DeleteCommand builder for performing row deletions on a specific table. public DeleteCommand Delete(string tableName) Parameters tableName string The name of the table from which rows will be deleted. Must be non-null and non-empty. If no table exists with this name, the resulting Execute() call will return 0. Returns DeleteCommand A new DeleteCommand instance tied to this database and the specified table name. The returned command supports method chaining for Where filters followed by Execute. Remarks Example usage: int count = db.Delete(\"Products\") .Where(Operator.LESS_THAN, \"Quantity\", 10) .Execute(); This will delete all rows from \"Products\" where the \"Quantity\" column is less than 10. Internally, DeleteCommand holds a reference to this GlasgowDB instance and the target table name. All Where filters are stored until Execute is called. DropTable(string) Deletes (drops) a table and all its contents from the database. public bool DropTable(string TableName) Parameters TableName string The name of the table to remove. Must be non-null and case-sensitive. If no such table exists, no exception is thrown and the method returns false. Returns bool true if the table was found and removed; false if the table did not exist. Remarks Once a table is dropped, all schema information (column names) and row data are lost. There is no built-in undo/restore; callers should handle backups if necessary. Example: bool removed = db.DropTable(\"Orders\"); if (!removed) Console.WriteLine(\"No table named 'Orders' existed.\"); InsertInto(string, string[], object[]) Inserts a new row into the specified table. If the table does not yet exist, it is automatically created with the provided columns. If new columns appear in ColumnNames that are not in the existing table schema, they will be added dynamically. public void InsertInto(string TableName, string[] ColumnNames, object[] Values) Parameters TableName string The name of the table into which to insert the new row. Must be non-null and non-empty. ColumnNames string[] An array of column names corresponding one-to-one with Values. If the table does not exist, these column names define its initial schema. If the table exists, any column in this array that is not already in the table’s schema will be appended to Table.ColumnNames. Values object[] An array of objects representing the data for the new row. The length of this array must match the length of ColumnNames. Supported value types include: null (serialized as Null), int, long, double, float, decimal, string, bool, DateTime, and byte[]. Other types will cause an exception when saving to disk. Remarks Internally, this method performs these steps: If TableName does not exist in Database, calls CreateTable(string, params string[]) with the provided columns. For each column name in ColumnNames, if that column is not already present in table.ColumnNames, add it to the schema. Validates that ColumnNames.Length == Values.Length. If not, throws ArgumentException. Constructs a new Dictionary<string, object> mapping each column name to its corresponding value. Null values should be represented as GetNullObject(). Appends the new dictionary to table.Rows. After insertion, the new row is immediately visible to subsequent Select operations. There is no validation of value types against an earlier schema (e.g., you could store an integer in a column that previously held strings). It is the caller’s responsibility to ensure type consistency. Exceptions ArgumentException Thrown when: TableName is null or empty. ColumnNames and Values have different lengths. A ColumnNames entry is null or empty. Select(string, params string[]) Retrieves a ResultSet containing rows from the specified table, projected onto the specified columns. Allows further filtering, ordering, and transformation. public ResultSet Select(string TableName, params string[] ColumnNames) Parameters TableName string The name of the table to select from. If the table does not exist, an empty ResultSet is returned. ColumnNames string[] A variable-length list of column names to include in the result. Columns that do not exist in the table schema are ignored. If no valid column names are specified, the returned ResultSet will have zero columns and, if the table exists, all rows will appear with null placeholders. Returns ResultSet A ResultSet containing: RowsIf the table exists, its internal row list (Table.Rows) is used; otherwise, an empty list. ColumnsThe subset of ColumnNames that exist in the table schema. Database referenceA reference to this GlasgowDB is stored for potential further operations. Remarks The returned ResultSet enables fluent operations: Where(...) to filter rows. OrderBy(...) to sort. Union(...) to combine with other sets. ToList() to materialize the final list of dictionaries. If the table does not exist, this method returns a ResultSet initialized with: Rows = an empty List<Dictionary<string, object>> SelectedColumns = all requested ColumnNames (converted to a List<string>) Database = this GlasgowDB instance This allows callers to chain Where or OrderBy calls safely, but ToList() will return an empty list. Performance: The Select method does not copy row data; it simply passes a reference to the table’s internal List<Dictionary<string, object>>. Subsequent filtering and ordering operations work on that reference, so if the underlying table is modified after Select is called but before ToList(), results may vary."
  },
  "api/Glasgow.Null.html": {
    "href": "api/Glasgow.Null.html",
    "title": "Class Null | Glasgow",
    "summary": "Class Null Namespace Glasgow Assembly Glasgow.dll Provides a type-safe, singleton-based representation of null or missing values within the GlasgowDB system, especially in scenarios where null cannot be used directly or unambiguously. In many serialization, storage, or transport layers, the native null reference in .NET may lose semantic meaning or cause ambiguity, especially when dealing with heterogeneous data structures or binary serialization formats that don't inherently preserve null as a unique concept. To solve this, the GlasgowDB system introduces a special singleton object that acts as a \"boxed null.\" This object can be safely stored, compared, and transferred in any context where a non-null reference is required but the semantic value is intended to represent the absence of meaningful data. public sealed class Null Inheritance object Null Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Methods GetNullObject() Retrieves the singleton instance used to represent null or missing values in GlasgowDB. This method provides a consistent reference to the special null object. Consumers can use it to assign values that semantically mean \"no value\" in a database context. Example usage: var nullValue = Null.GetNullObject(); myRow[\"LastName\"] = nullValue; A reference-equal, immutable object representing a logical null within the database. public static object GetNullObject() Returns object IsNullObject(object) Determines whether a given object is the singleton null representation used by GlasgowDB. This is a reference comparison that returns true only when the input object is exactly the same instance as the internal null marker. Example usage: if (Null.IsNullObject(value)) Console.WriteLine(\"Value is considered null in GlasgowDB.\"); The object to evaluate. true if obj is the singleton null marker; otherwise, false. public static bool IsNullObject(object obj) Parameters obj object Returns bool"
  },
  "api/Glasgow.Operator.html": {
    "href": "api/Glasgow.Operator.html",
    "title": "Enum Operator | Glasgow",
    "summary": "Enum Operator Namespace Glasgow Assembly Glasgow.dll Enumerates the available comparison operators used for filtering, searching, and conditional evaluations within GlasgowDB queries. These operators define how a particular field or value in a dataset should be evaluated against a given condition during query execution. They are typically used in where-clause expressions, filter functions, or conditional indexes. The applicable operators depend on the data type of the field being compared. For example, numeric and temporal fields support range-based comparisons (e.g., LESS_THAN), whereas string fields support pattern-based matching (e.g., CONTAINS). public enum Operator Fields CONTAINS = 6 Checks if a string contains the specified substring (case-insensitive). ENDS_WITH = 8 Checks if a string ends with the specified substring (case-insensitive). EQUALS = 0 Checks if two values are equal. GREATER_THAN = 3 Checks if a numeric or DateTime value is greater than the comparison value. GREATER_THAN_OR_EQUAL = 5 Checks if a numeric or DateTime value is greater than or equal to the comparison value. LESS_THAN = 2 Checks if a numeric or DateTime value is less than the comparison value. LESS_THAN_OR_EQUAL = 4 Checks if a numeric or DateTime value is less than or equal to the comparison value. NOT_EQUALS = 1 Checks if two values are not equal. STARTS_WITH = 7 Checks if a string starts with the specified substring (case-insensitive)."
  },
  "api/Glasgow.QueryBase.html": {
    "href": "api/Glasgow.QueryBase.html",
    "title": "Class QueryBase | Glasgow",
    "summary": "Class QueryBase Namespace Glasgow Assembly Glasgow.dll Represents an abstract base class designed to facilitate query-building operations over tabular data structures. This class provides core functionality for defining and applying filter conditions to a collection of rows, where each row is represented as a dictionary of column names and corresponding values. public abstract class QueryBase Inheritance object QueryBase Derived DeleteCommand ResultSet UpdateCommand Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Classes inheriting from QueryBase can leverage its flexible filtering logic to build complex queries without directly dealing with predicate composition or row traversal. It is suitable for in-memory querying of tabular datasets such as CSV, database result sets, or other structured row-oriented formats. Constructors QueryBase() Initializes a new instance of the QueryBase class and sets up an empty list of row filter predicates. protected QueryBase() Fields _filters Holds a list of filter predicates to be applied to each row. Each predicate is a function that takes a row (dictionary of column→value) and returns a boolean indicating whether the row satisfies the filter. protected List<Func<Dictionary<string, object>, bool>> _filters Field Value List<Func<Dictionary<string, object>, bool>> Methods ApplyFilters(IEnumerable<Dictionary<string, object>>) Applies all filter conditions accumulated via Where<T>(Operator, string, object) to a given sequence of rows. Only rows that satisfy every predicate in the internal filter list are included in the result. protected IEnumerable<Dictionary<string, object>> ApplyFilters(IEnumerable<Dictionary<string, object>> Rows) Parameters Rows IEnumerable<Dictionary<string, object>> The collection of rows to be filtered, where each row is a dictionary of column values. Returns IEnumerable<Dictionary<string, object>> A filtered IEnumerable<T> containing only the rows that match all defined filter predicates. IsNumericType(Type) Determines whether a given Type object represents a numeric data type. Supported types include: int, long, double, float, decimal, short, and byte. protected static bool IsNumericType(Type Type) Parameters Type Type The type to evaluate. Returns bool true if the specified Type is one of the recognized numeric types; otherwise, false. Where<T>(Operator, string, object) Adds a filter condition to this query based on a comparison operator, column name, and value. Supports comparisons for numeric types, strings (including wildcard, contains, starts/ends-with), DateTime, boolean, and byte array equality. public T Where<T>(Operator Operation, string ColumnName, object Value) where T : QueryBase Parameters Operation Operator The comparison operator to apply (e.g., EQUALS, NOT_EQUALS, LESS_THAN, etc.). ColumnName string The name of the column on which to apply the filter condition. Value object The value to compare against. Its type must match the data type stored in the column. Returns T The current query instance cast to T, enabling method chaining. Type Parameters T The concrete query type that inherits from QueryBase. This allows fluent chaining by returning the derived type. Remarks Supports filtering on various data types including: Numeric types: performs mathematical comparisons. Strings: supports equality, wildcard, substring, prefix/suffix match. DateTime: supports chronological comparisons. Booleans and byte arrays: supports equality operations. If either the row value or the provided value is null, they are only considered equal if both are null. WildcardMatch(string, string) Performs a case-insensitive pattern match between the input string and a specified wildcard pattern. The pattern can contain the '*' character to represent zero or more characters. protected static bool WildcardMatch(string Text, string Pattern) Parameters Text string The input string to evaluate. Pattern string A wildcard string where '' acts as a wildcard character matching any number of characters. For example: \"Jo\" matches \"John\", \"Joanna\", but not \"Alan\". Returns bool true if the Text matches the Pattern; otherwise, false."
  },
  "api/Glasgow.ResultSet.html": {
    "href": "api/Glasgow.ResultSet.html",
    "title": "Class ResultSet | Glasgow",
    "summary": "Class ResultSet Namespace Glasgow Assembly Glasgow.dll Represents the result of a SELECT query operation within GlasgowDB. The ResultSet class encapsulates a filtered, ordered subset of data rows retrieved from the underlying GlasgowDB in-memory database. Each row is represented as a dictionary mapping column names to their corresponding values. This class supports fluent method chaining for applying WHERE clauses, ordering, and union operations to shape and refine query results. This class inherits from QueryBase and utilizes internal logic for comparing, filtering, and manipulating rows based on column values, enabling dynamic, composable queries. public class ResultSet : QueryBase Inheritance object QueryBase ResultSet Inherited Members QueryBase._filters QueryBase.IsNumericType(Type) QueryBase.WildcardMatch(string, string) QueryBase.Where<T>(Operator, string, object) QueryBase.ApplyFilters(IEnumerable<Dictionary<string, object>>) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ResultSet(List<Dictionary<string, object>>, List<string>, GlasgowDB) Constructs a new instance of the ResultSet class using the provided collection of rows, selected columns, and a reference to the source database. public ResultSet(List<Dictionary<string, object>> Rows, List<string> SelectedColumns, GlasgowDB Database) Parameters Rows List<Dictionary<string, object>> The initial collection of rows (each a dictionary of column→value) for this result set. SelectedColumns List<string> The list of column names to include in the final output of this result set. Database GlasgowDB The GlasgowDB instance from which this result set originates. Methods Ascending(string) Specifies that the current result set should be ordered in ascending order based on the given column. This is a shorthand for calling OrderBy(string, SortDirection) with Ascending. public ResultSet Ascending(string ColumnName) Parameters ColumnName string The column name to order by in ascending order. Returns ResultSet The current ResultSet instance for further chaining. Descending(string) Specifies that the current result set should be ordered in descending order based on the given column. This is a shorthand for calling OrderBy(string, SortDirection) with Descending. public ResultSet Descending(string ColumnName) Parameters ColumnName string The column name to order by in descending order. Returns ResultSet The current ResultSet instance for further chaining. OrderBy(string, SortDirection) Sets the ordering for the result set using the specified column and sort direction. The actual sort will be applied when materializing the results (e.g., via ToList or equivalent). public ResultSet OrderBy(string ColumnName, SortDirection Direction) Parameters ColumnName string The column name to order by. Direction SortDirection The SortDirection indicating ascending or descending order. Returns ResultSet The current ResultSet instance for method chaining. ToList() Finalizes the query and returns the filtered, optionally ordered list of rows. Only columns specified in the SELECT clause are included in each result row. If an ordering has been defined using OrderBy(string, SortDirection) or its variants, the results are sorted accordingly. public List<Dictionary<string, object>> ToList() Returns List<Dictionary<string, object>> A List<T> representing the ordered and projected rows in this result set. Columns not present in a row are filled with a null-representing object. Union(ResultSet) Merges this current ResultSet with another result set, combining their rows into a single unified result. Duplicate rows (i.e., rows with identical values for all selected columns) are eliminated using a set-based comparison. This method is useful for combining results from multiple queries that share the same column schema. public ResultSet Union(ResultSet OtherResultSet) Parameters OtherResultSet ResultSet Returns ResultSet A new ResultSet containing the combined rows and the same selected columns. Where(Operator, string, object) Filters the result set to retain only those rows that satisfy the given comparison condition. This method evaluates each row using the specified operator against a target column and value. Type compatibility is enforced and various data types are supported, including strings (with wildcard), numbers, booleans, DateTime, and binary arrays. Wildcard matching using '*' is supported for strings via case-insensitive regular expression translation. public ResultSet Where(Operator Operation, string ColumnName, object Value) Parameters Operation Operator The comparison operator to apply (e.g., EQUALS, NOT_EQUALS, LESS_THAN, etc.). ColumnName string The name of the column on which to apply the filter. Value object The value to compare against. Its type must match the actual data type in the column. Returns ResultSet The current ResultSet instance, enabling method chaining for multiple WHERE clauses."
  },
  "api/Glasgow.SortComparer.html": {
    "href": "api/Glasgow.SortComparer.html",
    "title": "Class SortComparer | Glasgow",
    "summary": "Class SortComparer Namespace Glasgow Assembly Glasgow.dll Provides a flexible comparison mechanism for sorting heterogeneous objects in either ascending or descending order. This comparer is primarily used in data structures or algorithms that require ordering—such as sorting collections— and handles null values gracefully, ensuring deterministic and consistent comparisons. public class SortComparer : IComparer<object> Inheritance object SortComparer Implements IComparer<object> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks The comparison logic supports objects that implement IComparable, and falls back to case-insensitive string comparison if the objects do not implement that interface. This makes it suitable for generic scenarios where values of various runtime types may need to be sorted. Sorting direction is configurable at construction time via the IsAscending parameter. Constructors SortComparer(bool) Initializes a new instance of the SortComparer class with the specified sort order. public SortComparer(bool IsAscending) Parameters IsAscending bool A boolean flag indicating the desired sort order: true — values will be sorted in ascending order (e.g., A-Z, 1-9). false — values will be sorted in descending order (e.g., Z-A, 9-1). Methods Compare(object?, object?) Compares two objects and returns an integer that indicates their relative position in the sort order. public int Compare(object? X, object? Y) Parameters X object The first object to compare. May be null. Y object The second object to compare. May be null. Returns int An integer that indicates the relative order of the objects: < 0: X precedes Y in the sort order. 0: X and Y are considered equal in sort order. > 0: X follows Y in the sort order. The sign of the result is inverted if the comparer is configured for descending sort order. Remarks Comparison behavior: If both values are null, they are considered equal. null values are always considered lesser than non-null values. If both values implement IComparable, their native comparison is used. If native comparison is not available, a case-insensitive string comparison is used as fallback."
  },
  "api/Glasgow.SortDirection.html": {
    "href": "api/Glasgow.SortDirection.html",
    "title": "Enum SortDirection | Glasgow",
    "summary": "Enum SortDirection Namespace Glasgow Assembly Glasgow.dll Defines the direction in which a collection should be sorted. public enum SortDirection Fields Ascending = 0 Sort items in ascending order (smallest to largest). Descending = 1 Sort items in descending order (largest to smallest)."
  },
  "api/Glasgow.Table.html": {
    "href": "api/Glasgow.Table.html",
    "title": "Class Table | Glasgow",
    "summary": "Class Table Namespace Glasgow Assembly Glasgow.dll Represents a database table, containing a name, a collection of column names, and a collection of rows. Each row is stored as a dictionary mapping column names to their corresponding values. public sealed class Table Inheritance object Table Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors Table(string, IEnumerable<string>?) Initializes a new instance of the Table class with the specified name and optional initial columns. public Table(string TableName, IEnumerable<string>? Cols = null) Parameters TableName string The name to assign to this table. Cols IEnumerable<string> An optional enumerable of column names to initialize the table schema. If null, the table starts with an empty list of columns. Properties ColumnNames Gets or sets the list of column names defined for this table. public List<string> ColumnNames { get; set; } Property Value List<string> Name Gets or sets the name of this table. public string Name { get; set; } Property Value string Rows Gets or sets the collection of rows in this table. Each row is represented as a dictionary where keys are column names and values are the data entries. public List<Dictionary<string, object>> Rows { get; set; } Property Value List<Dictionary<string, object>>"
  },
  "api/Glasgow.UpdateCommand.html": {
    "href": "api/Glasgow.UpdateCommand.html",
    "title": "Class UpdateCommand | Glasgow",
    "summary": "Class UpdateCommand Namespace Glasgow Assembly Glasgow.dll Constructs and runs an UPDATE operation against a specified table in a GlasgowDB instance. This class leverages the filtering functionality inherited from QueryBase to enable WHERE clauses that refine which rows to update. Each Where(Operator, string, object) call adds an additional predicate: all predicates are combined with logical AND semantics. Example usage: int rowsAffected = db.Update(\"Users\") .Set(\"IsActive\", false) .Where(Operator.LESS_THAN, \"LastLogin\", someDate) .Execute(); This example sets the IsActive column to false for all rows in the \"Users\" table whose LastLogin is earlier than someDate. If the specified table does not exist in the database, Execute() returns zero without throwing. public class UpdateCommand : QueryBase Inheritance object QueryBase UpdateCommand Inherited Members QueryBase._filters QueryBase.IsNumericType(Type) QueryBase.WildcardMatch(string, string) QueryBase.Where<T>(Operator, string, object) QueryBase.ApplyFilters(IEnumerable<Dictionary<string, object>>) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors UpdateCommand(GlasgowDB, string) Constructs and runs an UPDATE operation against a specified table in a GlasgowDB instance. This class leverages the filtering functionality inherited from QueryBase to enable WHERE clauses that refine which rows to update. Each Where(Operator, string, object) call adds an additional predicate: all predicates are combined with logical AND semantics. Example usage: int rowsAffected = db.Update(\"Users\") .Set(\"IsActive\", false) .Where(Operator.LESS_THAN, \"LastLogin\", someDate) .Execute(); This example sets the IsActive column to false for all rows in the \"Users\" table whose LastLogin is earlier than someDate. If the specified table does not exist in the database, Execute() returns zero without throwing. public UpdateCommand(GlasgowDB Instance, string Table) Parameters Instance GlasgowDB The GlasgowDB instance against which this update operation will be performed. All modifications occur directly in this instance's in-memory table store. Table string The name of the table whose rows will be updated. Must be a non-null, non-empty string; if the table does not exist, no action is taken. Methods Execute() Executes the UPDATE operation against the underlying table, modifying all rows that satisfy the accumulated filter predicates. If the table does not exist, no rows are updated and zero is returned. public int Execute() Returns int The number of rows successfully updated in the table. Remarks Algorithm: Verify that the target table exists in DbInstance.Database. If not, return 0 immediately. Iterate through each row in table.Rows. For each row, evaluate all predicates in _filters (inherited from QueryBase). Only if every predicate returns true is the row considered for updating. For each matching row, iterate through all key/value pairs in Updates. Assign the new value to row[update.Key]. If the column does not exist in the table schema, add update.Key to table.ColumnNames so that future operations recognize it. Increment updatedCount for each row modified. Return updatedCount once all rows have been processed. Notes on Type Handling: Numeric comparators (<, >, etc.) only apply if both the existing row value and Value are numeric types (int, long, double, float, decimal, short, or byte). String comparisons (e.g., Operator.CONTAINS, Operator.STARTS_WITH, Operator.ENDS_WITH) perform case-insensitive matches. Wildcards (using '*') are also supported when Operator.EQUALS or Operator.NOT_EQUALS is used with a pattern containing '*'. DateTime comparisons use DateTime comparison operators directly. Boolean comparisons only support Operator.EQUALS and Operator.NOT_EQUALS. Byte-array comparisons (byte[]) only support Operator.EQUALS and Operator.NOT_EQUALS, using sequence equality. Thread Safety: GlasgowDB is not inherently thread-safe. If multiple threads perform UpdateCommand on the same table concurrently without external synchronization, the result may be unpredictable due to race conditions on List<Dictionary<string, object>>.Remove and direct assignment to row[column]. Side Effects: Once Execute() is called, the in-memory table is modified immediately. There is no built-in rollback or versioning; if an update should be undone, the caller must manually revert changes or use a backup/copy. Exceptions InvalidOperationException This method does not throw if the table is missing. However, if the internal state of the table or filters is corrupted (e.g., Table.Rows is null), unexpected exceptions (such as NullReferenceException) may propagate. Set(string, object) Specifies a column and its new value to be applied to rows matching the WHERE filters. Multiple Set(string, object) calls can be chained to update multiple columns at once. public UpdateCommand Set(string ColumnName, object Value) Parameters ColumnName string The name of the column to update. If this column does not already exist in a particular row, it will be added to that row and to ColumnNames. Column names are case-sensitive. Value object The new value to assign to ColumnName. Its runtime type should match the data type expected for that column (e.g., int, string, DateTime, etc.). Returns UpdateCommand The same UpdateCommand instance, allowing additional Set(string, object) or Where(Operator, string, object) calls to be chained before executing. Remarks Each call to Set(string, object) replaces or adds a key/value pair in the internal Updates dictionary. If the same column is Set(string, object) more than once, the last value provided will be used. Where(Operator, string, object) Adds a filtering condition (WHERE clause) to this update command, matching only rows where the specified column satisfies the comparison operator against the provided value. public UpdateCommand Where(Operator Operation, string ColumnName, object Value) Parameters Operation Operator The comparison operator to apply (e.g., EQUALS, NOT_EQUALS, LESS_THAN, etc.). See Operator for all supported types. ColumnName string The name of the column to compare. If a row lacks this column, that row is excluded. Value object The value to compare against. Must be of a compatible type for the column (e.g., numeric comparisons for numeric columns, string comparisons for text columns, etc.). Returns UpdateCommand The same UpdateCommand instance, allowing further chaining of Where(Operator, string, object) clauses. Remarks Internally, this method calls the generic Where<T>(Operator, string, object) implementation, which appends a predicate delegate into the inherited _filters list. When Execute() is called, only rows satisfying all accumulated predicates are updated."
  },
  "api/Glasgow.html": {
    "href": "api/Glasgow.html",
    "title": "Namespace Glasgow | Glasgow",
    "summary": "Namespace Glasgow Classes CryptographyUtil Provides utility methods for cryptographic operations used throughout GlasgowDB, including secure key derivation from passwords or passphrases. DatabaseIO Handles secure serialization and deserialization of a GlasgowDB instance to and from disk. This class provides AES-256-CBC encryption for secure database persistence, using a passphrase-derived key via PBKDF2 and a randomly generated Initialization Vector (IV) embedded at the start of the file. All data (including table structure and row content) is stored in a binary format after encryption. Security Considerations: Encryption uses AES-256-CBC for strong symmetric encryption. Keys are derived from passphrases using PBKDF2 to resist brute force attacks. The IV is stored unencrypted at the beginning of the file and is used for key derivation and decryption. Typical Usage: - Use SaveToFile(GlasgowDB, string, string) to persist a GlasgowDB securely. - Use LoadFromFile(string, string) to recover it using the same passphrase. DeleteCommand Constructs and runs a DELETE operation against a specified table in a GlasgowDB instance. This class leverages the filtering functionality inherited from QueryBase to enable WHERE clauses that refine which rows to remove. Each Where(Operator, string, object) call adds an additional predicate: all predicates are combined with logical AND semantics. Example usage: int deletedCount = db.Delete(\"Users\") .Where(Operator.EQUALS, \"IsActive\", false) .Where(Operator.LESS_THAN, \"LastLogin\", someDate) .Execute(); This example deletes all rows in the \"Users\" table that are inactive and have a last login earlier than someDate. If the specified table does not exist in the database, Execute() returns zero without throwing. GlasgowDB Represents an in-memory database that holds named tables and provides basic relational operations (CREATE, DROP, INSERT, SELECT, DELETE, UPDATE). All data is stored in memory as Table objects, each identified by a unique string name. This class is not thread-safe: concurrent modifications (e.g., two threads inserting into the same table) can lead to inconsistent state. If thread safety is required, external synchronization must be applied. Example usage: // Create a new database var db = new GlasgowDB(); // Create a table \"Users\" with columns \"Id\", \"Name\", \"Email\" db.CreateTable(\"Users\", \"Id\", \"Name\", \"Email\"); // Insert a row into \"Users\" db.InsertInto( \"Users\", new[] { \"Id\", \"Name\", \"Email\" }, new object[] { 1, \"Alice\", \"alice@example.com\" } ); // Query the \"Users\" table var results = db.Select(\"Users\", \"Id\", \"Name\") .Where(Operator.EQUALS, \"Name\", \"Alice\") .ToList(); foreach (var row in results) { Console.WriteLine($\"Id: {row[\"Id\"]}, Name: {row[\"Name\"]}\"); } // Delete inactive users int deleted = db.Delete(\"Users\") .Where(Operator.EQUALS, \"IsActive\", false) .Execute(); // Drop the \"Users\" table entirely bool dropped = db.DropTable(\"Users\"); Null Provides a type-safe, singleton-based representation of null or missing values within the GlasgowDB system, especially in scenarios where null cannot be used directly or unambiguously. In many serialization, storage, or transport layers, the native null reference in .NET may lose semantic meaning or cause ambiguity, especially when dealing with heterogeneous data structures or binary serialization formats that don't inherently preserve null as a unique concept. To solve this, the GlasgowDB system introduces a special singleton object that acts as a \"boxed null.\" This object can be safely stored, compared, and transferred in any context where a non-null reference is required but the semantic value is intended to represent the absence of meaningful data. QueryBase Represents an abstract base class designed to facilitate query-building operations over tabular data structures. This class provides core functionality for defining and applying filter conditions to a collection of rows, where each row is represented as a dictionary of column names and corresponding values. ResultSet Represents the result of a SELECT query operation within GlasgowDB. The ResultSet class encapsulates a filtered, ordered subset of data rows retrieved from the underlying GlasgowDB in-memory database. Each row is represented as a dictionary mapping column names to their corresponding values. This class supports fluent method chaining for applying WHERE clauses, ordering, and union operations to shape and refine query results. This class inherits from QueryBase and utilizes internal logic for comparing, filtering, and manipulating rows based on column values, enabling dynamic, composable queries. SortComparer Provides a flexible comparison mechanism for sorting heterogeneous objects in either ascending or descending order. This comparer is primarily used in data structures or algorithms that require ordering—such as sorting collections— and handles null values gracefully, ensuring deterministic and consistent comparisons. Table Represents a database table, containing a name, a collection of column names, and a collection of rows. Each row is stored as a dictionary mapping column names to their corresponding values. UpdateCommand Constructs and runs an UPDATE operation against a specified table in a GlasgowDB instance. This class leverages the filtering functionality inherited from QueryBase to enable WHERE clauses that refine which rows to update. Each Where(Operator, string, object) call adds an additional predicate: all predicates are combined with logical AND semantics. Example usage: int rowsAffected = db.Update(\"Users\") .Set(\"IsActive\", false) .Where(Operator.LESS_THAN, \"LastLogin\", someDate) .Execute(); This example sets the IsActive column to false for all rows in the \"Users\" table whose LastLogin is earlier than someDate. If the specified table does not exist in the database, Execute() returns zero without throwing. Enums DataTypes Enumerates all supported data types used by the GlasgowDB system for serializing and storing values in its internal tabular structure. Each enumeration value corresponds to a specific .NET type and dictates how the value is serialized, deserialized, stored, and interpreted within the database engine. These types ensure compatibility with common .NET primitives and are essential for consistent binary serialization handled by Glasgow.SerializerUtil. The Glasgow.SerializerUtil uses this enum as metadata to identify the type of value being serialized or deserialized, enabling type-safe reconstruction of data across sessions, storage layers, or transport boundaries. Operator Enumerates the available comparison operators used for filtering, searching, and conditional evaluations within GlasgowDB queries. These operators define how a particular field or value in a dataset should be evaluated against a given condition during query execution. They are typically used in where-clause expressions, filter functions, or conditional indexes. The applicable operators depend on the data type of the field being compared. For example, numeric and temporal fields support range-based comparisons (e.g., LESS_THAN), whereas string fields support pattern-based matching (e.g., CONTAINS). SortDirection Defines the direction in which a collection should be sorted."
  },
  "index.html": {
    "href": "index.html",
    "title": "| Glasgow",
    "summary": "Overview Glasgow is a flexible, modular, and lightweight .NET library designed to simplify the development of custom in-memory databases, data manipulation engines, and query interpreters. Whether you're building a data-driven application, prototyping a DSL, or implementing a custom query language, Glasgow provides the core infrastructure to parse, transform, evaluate, and manage structured data with precision and ease. Philosophically, Glasgow is built around the extensibility and clarity. It offers utilities for expression evaluation, query parsing, sorting, filtering, projection, and dynamic typing - all tailored for scenarios where traditional relational databases may be too heavyweight or rigid. The codebase is clean, self-contained, and designed to integrate easily into both small prototypes and large-scale production systems. Glasgow is a rich expression engine that supports arithmetic, logical, and comparison operations on typed data. Paired with a compact and efficient parser and a robust evaluation pipeline, Glasgow enables developers to define and execute queries and transformations without having to build a complete query engine from scratch. Use Cases Embedded Query Language: Build custom data query languages for analytics dashboards, configuration engines, or scripting environments. In-Memory Data Engine: Implement dynamic, in-memory data tables that support filtering, sorting, and projection. DSL Prototyping: Rapidly prototype domain-specific languages (DSLs) that require parsing and evaluation capabilities. ETL Pipelines: Integrate Glasgow into Extract-Transform-Load pipelines for structured data filtering and transformation. See Also Installation Examples License Glasgow is released under the MIT License. You are free to use, modify, and distribute this library in both commercial and non-commercial projects. Copyright 2025 Nathanne Isip Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "pages/examples.html": {
    "href": "pages/examples.html",
    "title": "| Glasgow",
    "summary": "Example Usage Loading and Saving Database to File These examples demonstrate how to persist a GlasgowDB instance to disk and retrieve it later. The database is encrypted using a password for secure storage. This allows you to save the entire in-memory database state and reload it later without reinitializing or repopulating data manually. GlasgowDB db = new GlasgowDB(); // Create database instance DatabaseIO.SaveToFile( // Save the database instance to file db, \"database.glasgow\", \"this_is_your_password\" ); // Load database from file with specified file name and password GlasgowDB db = DatabaseIO.LoadFromFile( \"database.glasgow\", \"this_is_your_password\" ); Creating Database This snippet shows how to initialize a new GlasgowDB instance and define tables within it. Each table is defined with a name and a list of columns. Tables are created dynamically and are ready to store and manipulate rows of data once defined. GlasgowDB db = new GlasgowDB(); // Create database instance db.CreateTable( // Create new table on the instance \"users\", // Name the table \"users\" \"id\", // These are column names ... \"username\", // | \"email\", // | \"age\", // | \"is_active\", // | \"created_at\", // | \"profile_pic\" // | ); db.CreateTable( // Create another table \"products\", // Name this table \"products\" \"product_id\", // Here's the column names ... \"name\", // | \"price\", // | \"stock_count\" // | ); Inserting Row to Table After creating tables, you can insert rows by specifying both the column names and the corresponding values in the correct order. The data can include strings, numbers, booleans, DateTime values, and even binary data such as images. The inserted values will be stored and indexed automatically. db.InsertInto( // Define the table name where the row will be added \"users\", // Row name array [ \"id\", \"username\", \"email\", \"age\", \"is_active\", \"created_at\", \"profile_pic\" ], // Values that will be put with the same // arrangement as row names above [ 1, \"alice_test_user\", \"alice@example.com\", 30, true, DateTime.UtcNow.AddDays(-10), Encoding.UTF8.GetBytes(\"some_image_data_alice\") ] ); db.InsertInto( // Define the table name where the row will be added \"products\", // Row name array [ \"product_id\", \"name\", \"price\", \"stock_count\" ], // Values that will be put with the same // arrangement as row names above [ 101, \"Laptop\", 1200.50, 10 ] ); Query and Data Fetching GlasgowDB includes a fluent query API for filtering, sorting, and selecting records. The following example demonstrates how to select users whose usernames start with \"bob\" and whose age is less than 30. Results are sorted by age in ascending order, and each row can be accessed like a dictionary for reading individual column values. // Select the following rows from the \"users\" table var users = db.Select( \"users\", \"id\", \"username\", \"email\", \"age\", \"created_at\" ) .Where(Operator.STARTS_WITH, \"username\", \"bob\") .Where(Operator.LESS_THAN, \"age\", 30) .Ascending(\"age\") .ToList(); // Iterate on the fetched rows foreach (var user in users) Console.WriteLine( $\"ID: {user[\"id\"]}, Username: {user[\"username\"]}, \" + $\"Email: {user[\"email\"]}, Age: {user[\"age\"]}, \" + $\"Created: {user[\"created_at\"]}\" );"
  },
  "pages/installation.html": {
    "href": "pages/installation.html",
    "title": "| Glasgow",
    "summary": "Installation Glasgow can be easily installed into your .NET project using NuGet Package Manager. Installation via NuGet Package Manager The simplest way to add Glasgow to your project is through NuGet. Using the .NET CLI Open your terminal or command prompt, navigate to your project's directory, and run the following command: dotnet add package Glasgow --version 1.0.0 Using Visual Studio Open your project in Visual Studio. Right-click on your project in the Solution Explorer and select \"Manage NuGet Packages...\". In the \"Browse\" tab, search for Glasgow. Select the Glasgow package and click \"Install\". Confirm the installation when prompted. Using PowerShell (Package Manager Console in Visual Studio) If you're in Visual Studio, you can also use the Package Manager Console: Go to Tools > NuGet Package Manager > Package Manager Console. In the console, run the following command: Install-Package Glasgow -Version 1.0.0 After installation, you can verify that the package is correctly referenced in your project file (e.g., .csproj). Look for an <PackageReference> entry similar to this: <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <OutputType>Exe</OutputType> <TargetFramework>net8.0</TargetFramework> <ImplicitUsings>enable</ImplicitUsings> <Nullable>enable</Nullable> </PropertyGroup> <ItemGroup> <PackageReference Include=\"Glasgow\" Version=\"1.0.0\" /> </ItemGroup> </Project>"
  }
}